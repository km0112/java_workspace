// Lab to follow up the 2nd test of the year,
// November 2022. Write algorithms and solutions
// to the test's 3 free response, CodingBat-styled
// questions.
//
// Notes:
//    1. the main method may NOT be modified in any way.
//    2. each of the 3 methods has an initial stub solution
//       that allows it to compile
//    3. for full credit you will write an algorithm in comment
//       form within each method and then write the Java code to
//       implement your algorithm.
//    4. to run your solution simply compile and then run FunctionLab.

public class FunctionLab
{
  public static void main(String[] args)
  {
    // test of nearFar:
    System.out.println("Testing method nearFar:");
    int A = 0;
    int[] B = {1,3,5,7,-3};
    int[] C = {2,17,-2,0,8};
    for( int i = 0; i < B.length;i++ )
    {
      System.out.printf("nearFar(%1d,%1d,%1d) = %b\n", A, B[i], C[i], nearFar(A, B[i], C[i]) );
    }
    System.out.println();

    // test of filterOut:
    String[] phrases = {"catcatdogcat","oooo","Mississippi Rississippi","llateateearlylatelayt","hello!"};
    String[] words   = {"cat","ooo","iss","late","bye!"};
    System.out.println("Testing method filterOut:");
    for( int i = 0; i < phrases.length; i++ )
    {
      String p = phrases[i], w = words[i];
      System.out.printf("filterOut(\"%1s\",\"%1s\") = \"%1s\"\n", p, w, filterOut(p,w) );
    }
    System.out.println();

    // test of countX:
    String[] strs = {"abcdxfXeXXx","abcdefghi","exit","X (or x) marks the spot", "xxXXx"};
    System.out.println("Testing method countX:");
    for( int i = 0; i < strs.length; i++ )
    {
      System.out.printf("countX(\"%1s\") = %1d\n", strs[i], countX(strs[i]) );
    }
    System.out.println();
  }

  // Method I:
  // returns true if one of B or C is "near" A while
  // the other is "far" from A. "near" is defined as
  // being within 2 or less of A, while "far" is defined
  // as being 3 or more away from A.
  // precondition: none
  private static boolean nearFar(int A, int B, int C)
  {
    // Replace this comment with your algorithm and the
    // Java code to implement your algorithm.

    return false; // stub solution
  }

  // Method II:
  // returns a String that is comprised of the input String phrase,
  // but which has NO occurences within it of the String word
  // precondition: word is non-empty
  private static String filterOut(String phrase, String word)
  {
    // Replace this comment with your algorithm and the
    // Java code to implement your algorithm.

    return phrase; // stub solution
  }

  // Method III:
  // Returns the number of times that "x" or "X" occurs in str
  // precondition: none
  private static int countX(String str)
  {
    // Replace this comment with your algorithm and the
    // Java code to implement your algorithm.

    return 0; // stub solution
  }
}
